< 배당금프로젝트 - 간단하게 축약한 회원관리 >
회원관리기능은 security 패키지에서 관리한다.


=============================== << 스프링 시큐리티 >> ===============================
- @ElementCollection
  : 1:N의 매핑으로 테이블에 데이터가 저장.
  - 참고 블로그 : https://velog.io/@thsruddl77/Basic-attribute-type-should-not-be-a-container

- PasswordEncoder


< 스프링 시큐리티를 이용한 로그인 (최소한의) 인증 구현 >
1. 사용자 Entity (MemberEntity.java)
   - 인증 시 사용할 Entity.
   - UserDetails 인터페이스 구현.

2. 로그인인증 Service (MemberService.java)
   - 인증 시 사용할 서비스.
   - UserDetailsService 인터페이스 구현.
   - loadUserByUsername() 메서드 필수구현.

3. JwtAuthenticationFilter.java
   - 인증필터구현
   - OncePerRequestFilter 상속받아 생성.
   - doFilterInternal() 메서드 필수구현.
   - 사용자가 signup, signin api를 호출했을 때 바로 해당 컨트롤러로 요청이 들어오는 것은 아니다.
     컨트롤러로 요청이 들어오기 전에 제일 먼저 필터를 거치게 된다.
     ( 컨트롤러 요청 -> 필터 -> 서블릿 -> 인터셉터 -> aop layer를 거친 후 컨트롤러 호출.
       응답을 내보낼 때는 위의 과정을 반대로 거쳐 내보낸다. )
     OncePerRequestFilter 라는 필터를 정의해주게 되면 모든 요청이 올 때 마다 (한 요청당 한 번)
     필터 실행.
     따라서 컨트롤러 실행 전의 request. 컨트롤러 실행 후 응답 시 response를 가공가능.
     So, 컨트롤러에 요청이 들어올 때 마다 사용자토큰의 포함여부, 유효성 여부 등 확인가능.

4. SecurityConfiguration.java
   - 스프링 시큐리티 설정정보.
   - WebSecurityConfigurerAdapter 상속받아 구현.
   - @EnableWebSecurity 어노테이션 적용필수.
   - @EnableGlobalMethodSecurity(prePostEnabled = true)
     : configure() 메서드에서 http.antMatches().gasRole()을 통해
       특정 권한을 가진 사람만 해당 경로에 접근할 수 있도록 설정가능하지만
       hasRole() 권한체크를 해당 설정파일 외부에서 어노테이션으로 처리가능하도록 하기위해 추가하는 어노테이션.
       (해당 어노테이션을 사용해 '필요권한설정'을 해당 설정파일에서 모두 부여하지않고
        실제 권한을 적용할 컨트롤러에서 직접설정 가능하도록 한다.)

   - rest api로 JWT 토큰 인증방식을 구현 시 설정필수
     1. 사용하지 않을 부분에 대한 disable 처리
        - http.httpBasic().disable().csrf().disable()
     2. session stateless 처리
        : 로그인을 session이 아닌 JWT 토큰으로 구현했기에 상태정보를 저장하지 않는 stateless 특징가짐.
          (세션으로 구현시에는 상태를 가지고 jwt 토큰을 이용해 구현시 상태를 가지지않음.)
        - sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)

   - permitAll()
     : 해당경로에 대해 인증없이 무조건적으로 권한허용.
     : 회원가입, 로그인의 경우는 토큰없이 접근가능해야함. (JWT 토큰은 로그인 후 생성되므로.)
     - .and()
        .authorizeRequests()
        .antMatchers("/**/signup", "/**/signin").permitAll()

   - addFilterBefore() : 필터의 실행 순서 정의
     - UsernamePasswordAuthenticationFilter.class : 스프링에서 정의되어있는 필터
     - .and()
        .addFilterBefore(this.authenticationFilter, UsernamePasswordAuthenticationFilter.class);

5. Controller에 인증권한부여
   - @PreAuthorize("hasRole('WRITE')")
     : SecurityConfiguration.java에 @EnableGlobalMethodSecurity(prePostEnabled = true) 적용으로
       컨트롤러에서 권한직접부여 가능.
     : 해당 어노테이션을 Controller에 추가 시 쓰기 권한이 있는 유저만 해당 api 호출가능.
     : hasRole()에는 Authority.java 파일에서 권한정의 시 작성해준 값에서 ROLE_ 를 제외한 문자열작성.
       ('ROLE_'이라는 prefix로 권한을 시작하는 이유는 스프링 시큐리티가 지원하는 기능들을 쓰기 위함임.)
   - 권한이 없는 사용자가 해당 api 호출 시 403 (Forbidden)에러 출력됨.

6. api 호출시 인증관련 에러해결
   - 발생에러
     : org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.example.dividend.persist.entity.MemberEntity.roles, could not initialize proxy - no Session
       	at org.hibernate.collection.internal.AbstractPersistentCollection.throwLazyInitializationException(AbstractPersistentCollection.java:606) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
       	at org.hibernate.collection.internal.AbstractPersistentCollection.withTemporarySessionIfNeeded(AbstractPersistentCollection.java:218) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
       	at org.hibernate.collection.internal.AbstractPersistentCollection.initialize(AbstractPersistentCollection.java:585) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
       	at org.hibernate.collection.internal.AbstractPersistentCollection.read(AbstractPersistentCollection.java:149) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
       	at org.hibernate.collection.internal.PersistentBag.iterator(PersistentBag.java:387) ~[hibernate-core-5.4.32.Final.jar:5.4.32.Final]
       	at java.base/java.util.Spliterators$IteratorSpliterator.estimateSize(Spliterators.java:1821) ~[na:na]
       	at java.base/java.util.Spliterator.getExactSizeIfKnown(Spliterator.java:408) ~[na:na]
       	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:483) ~[na:na]
       	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na]
       	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913) ~[na:na]
       	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na]
       	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578) ~[na:na]
       	at com.example.dividend.persist.entity.MemberEntity.getAuthorities(MemberEntity.java:40) ~[main/:na]
       	at com.example.dividend.security.TokenProvider.getAuthentication(TokenProvider.java:103) ~[main/:na]
   - 해결방법 : role은 호출 시 여러정보를 가져오는 list 형태이기에 호출부에 @Transactional 어노테이션을 추가해줘야한다.
   - 도움받은 블로그 : https://velog.io/@chocochip/failed-to-lazily-initialize-a-collection-of-role-%EC%97%90%EB%9F%AC





=============================== << JWT (Json Web Token) >> ===============================
1. JWT
   : 사용자 인증 및 식별에 사용되는 토큰
   - 토큰은 사용자 정보를 포함한다.
   - Java 뿐 아닌 다양한 언어를 지원한다. (토큰을 주고받는 서버가 동일하지 않아도 된다.)
   - 한번 토큰이 생성되면 상태나 토큰에 대한 정보를 서버에서 관리하지 않는 것이 특징이다.
     (토큰 만료시간 필수, 토큰에 만료시간이 존재하지 않으면 이후에 토큰 유출시 임의로 서버에서 처리가 불가하기에 보안문제 발생가능.)
   - 세션과 같은 방법으로 사용자 정보를 처리할수도 있지만
     특별히 다른 방법을 써야하는 이유가 있는게 아니라면
     토큰을 이용한 구현방법이 일반적이기도 하고 세션방식보다 장점도 많아서
     토큰인증의 가장 기본인 JWT에 대해 이해해야지 이후에 서드파티(?)를 이용한 로그인, OAuth 같은 인증방법들도 적용가능.


2. JWT 구조
   : 아래의 구조는 .으로 구분된다.
   - Header : 토큰의 타입(ex JWT), 적용된 알고리즘에 대한 정보.
   - Payload : 사용자와 토큰에 대한 속성 정보 (ex 로그인한 사용자의 이름, 토큰만료시간 등)
               Payload는 JWT 토큰만 가지고 있으면 누구나 디코딩해서 정보를 열어볼 수 있다는 특징이있다.
               따라서 비밀번호같은 민감정보는 포함하고 있으면 안된다.
   - Signature : 서명에 대한 부분.
                 토큰이 유효한지 위조된 것인지 확인하기 위해 사용된다.
                 서명을 하기위해 해당 비밀키를 필요로하게 된다.


< 토큰생성 >
1. 비밀키 생성
   - 토큰 생성시 HS512알고리즘 사용을 위해 -> 512비트(64바이트 이상)의 시크릿키 사용.
   - 평문을 사용하기보다는 base64로 인코딩한 값을 사용.
   - 터미널에서 생성가능.
     : 평문키 파일을 생성해 base64로 인코딩한 새파일 생성
        C:\workspace\Dividend\src\main\resources\token>certutil -encode jwt_secret_key.txt jwt_secret_key_encoding.b64
        입력 길이 = 46
        출력 길이 = 122
        CertUtil: -encode 명령이 성공적으로 완료되었습니다.
   - 도움받은 블로그 : https://interconnection.tistory.com/120

2. application.yml에 설정 추가
   - jwt:
        secret: '생성한 비밀키 등록'

3. TokenProvider.java





=============================== << 암호화 알고리즘 >> ===============================
평문 : 암호화 전 해독가능한 상태
암호문 : 암호화된 형태의 메시지
암호화(encryption) : 평문 -> 암호문
복호화(decryption) : 암호문 -> 평문
대칭키 : 동일키를 이용한 암,복호화시 대칭키를 사용한다고 한다.
비대칭키 : 메시지를 암,복호화하는 키가 다르면 비대칭키를 쓰는 알고리즘을 사용한 것이다.





=============================== << 예외처리 >> ===============================
서비스에서는 예외를 잘 처리하는 것이 중요하다.
예외가 발생하지 않도록 하는 것도 중요하지만 에러를 잘 발생시켜주는 것도 중요하다.
클라이언트, 서버 개발자가 에러 내용을 보고 대응할 수 있도록 에러를 발생시켜줘야한다.
따라서 서버에서 문제 발생 시 Http Status Code를 기반으로 해당 문제에 대응되는 상태코드를 응답으로 내려줘야한다.
에러코드를 정확히 내려주면 어디서 어떤 문제가 발생했는지 파악이 쉽다.
또한 클라이언트에서도 발생한 에러에 대한 처리를 각각 수행 가능하도록 할 수 있게 한다.


< HTTP Status Code >
200 : 성공
400 : 클라이언트에서 잘못된 요청 시 발생하는 에러.
    - 400 Bad Request : 잘못된 요청
    - 401 Unauthorized : 로그인 시 인증처리관련 문제 발생으로 인한 에러.
    - 403 Forbidden : 접근이 금지된 경로에 대한 요청시 발생 에러.
    - 404 Not Found
500 : 서버에서 로직상 발생하는 에러.


< Custom Exception을 이용한 예외처리 >
- 에러 처리를 위한 여러 방법 중 하나.

현재 프로젝트에서는 RuntimeException 에러 발생시 단순히 500 상태코드를 응답으로 반환한다.
그리고 콘솔창으로 확인하면 실제 발생한 에러에 대한 내용을 확인 가능하다.
위의 에러처리는 좋은 에러처리로 볼 수 없다.
예를 들어 배당금내역 조회 시 등록되어있지 않은 회사에 대한 배당금내역을 조회하는 경우 500 에러가 발생하는데
사실 이 경우에는 클라이언트에서 등록되어있지 않은 회사에 대한 요청을 한 것이므로 서버 로직상에서 에러가 발생한 경우로 보기 어렵다.
클라이언트에서 잘못된 요청이 서버에 들어온 경우이므로 400번대 에러가 적합하다.

1. 에러발생
   : 기존 new RuntimeException() 으로 발생시켰던 에러를
     Custom Exception 구현체를 이용해 상황에 맞는 에러를 발생시키도록 처리한다.
2. ExceptionHandler를 통한 에러처리
   : new Exception() 으로 발생시켰던 에러를 처리하기 위해
     특정 에러에 대한 처리를 다루는 핸들러를 생성한다.
   - @ControllerAdvice 어노테이션을 추가.
   - 서비스에서 지정된 에러가 발생하면 해당 에러를 catch해 http response로 던져준다.
   - 필터와 비슷하게 컨트롤러보다 좀 더 바깥쪽에서 동작하는 layer.
     (필터처럼 멀지않고 컨트롤러와 상대적으로 가까움.)






