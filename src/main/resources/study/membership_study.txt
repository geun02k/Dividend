< 배당금프로젝트 - 간단하게 축약한 회원관리 >
회원관리기능은 security 패키지에서 관리한다.


=============================== << 스프링 시큐리티 >> ===============================
- @ElementCollection
  : 1:N의 매핑으로 테이블에 데이터가 저장.
  - 참고 블로그 : https://velog.io/@thsruddl77/Basic-attribute-type-should-not-be-a-container

- PasswordEncoder


< 스프링 시큐리티를 이용한 로그인 (최소한의) 인증 구현 >
1. 사용자 Entity (MemberEntity.java)
   - 인증 시 사용할 Entity.
   - UserDetails 인터페이스 구현.

2. 로그인인증 Service (MemberService.java)
   - 인증 시 사용할 서비스.
   - UserDetailsService 인터페이스 구현.
   - loadUserByUsername() 메서드 필수구현.

3. JwtAuthenticationFilter.java
   - 인증필터구현
   - OncePerRequestFilter 상속받아 생성.
   - doFilterInternal() 메서드 필수구현.
   - 사용자가 signup, signin api를 호출했을 때 바로 해당 컨트롤러로 요청이 들어오는 것은 아니다.
     컨트롤러로 요청이 들어오기 전에 제일 먼저 필터를 거치게 된다.
     ( 컨트롤러 요청 -> 필터 -> 서블릿 -> 인터셉터 -> aop layer를 거친 후 컨트롤러 호출.
       응답을 내보낼 때는 위의 과정을 반대로 거쳐 내보낸다. )
     OncePerRequestFilter 라는 필터를 정의해주게 되면 모든 요청이 올 때 마다 (한 요청당 한 번)
     필터 실행.
     따라서 컨트롤러 실행 전의 request. 컨트롤러 실행 후 응답 시 response를 가공가능.
     So, 컨트롤러에 요청이 들어올 때 마다 사용자토큰의 포함여부, 유효성 여부 등 확인가능.

4. SecurityConfiguration.java
   - 스프링 시큐리티 설정정보.
   - WebSecurityConfigurerAdapter 상속받아 구현.
   - @EnableWebSecurity 어노테이션 적용필수.
   - @EnableGlobalMethodSecurity(prePostEnabled = true)
     : configure() 메서드에서 http.antMatches().gasRole()을 통해
       특정 권한을 가진 사람만 해당 경로에 접근할 수 있도록 설정가능하지만
       hasRole() 권한체크를 해당 설정파일 외부에서 어노테이션으로 처리가능하도록 하기위해 추가하는 어노테이션.
       (해당 어노테이션을 사용해 '필요권한설정'을 해당 설정파일에서 모두 부여하지않고
        실제 권한을 적용할 컨트롤러에서 직접설정 가능하도록 한다.)

   - rest api로 JWT 토큰 인증방식을 구현 시 설정필수
     1. 사용하지 않을 부분에 대한 disable 처리
        - http.httpBasic().disable().csrf().disable()
     2. session stateless 처리
        : 로그인을 session이 아닌 JWT 토큰으로 구현했기에 상태정보를 저장하지 않는 stateless 특징가짐.
          (세션으로 구현시에는 상태를 가지고 jwt 토큰을 이용해 구현시 상태를 가지지않음.)
        - sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)

   - permitAll()
     : 해당경로에 대해 인증없이 무조건적으로 권한허용.
     : 회원가입, 로그인의 경우는 토큰없이 접근가능해야함. (JWT 토큰은 로그인 후 생성되므로.)
     - .and()
        .authorizeRequests()
        .antMatchers("/**/signup", "/**/signin").permitAll()

   - addFilterBefore() : 필터의 실행 순서 정의
     - UsernamePasswordAuthenticationFilter.class : 스프링에서 정의되어있는 필터
     - .and()
        .addFilterBefore(this.authenticationFilter, UsernamePasswordAuthenticationFilter.class);





=============================== << JWT (Json Web Token) >> ===============================
1. JWT
   : 사용자 인증 및 식별에 사용되는 토큰
   - 토큰은 사용자 정보를 포함한다.
   - Java 뿐 아닌 다양한 언어를 지원한다. (토큰을 주고받는 서버가 동일하지 않아도 된다.)
   - 한번 토큰이 생성되면 상태나 토큰에 대한 정보를 서버에서 관리하지 않는 것이 특징이다.
     (토큰 만료시간 필수, 토큰에 만료시간이 존재하지 않으면 이후에 토큰 유출시 임의로 서버에서 처리가 불가하기에 보안문제 발생가능.)
   - 세션과 같은 방법으로 사용자 정보를 처리할수도 있지만
     특별히 다른 방법을 써야하는 이유가 있는게 아니라면
     토큰을 이용한 구현방법이 일반적이기도 하고 세션방식보다 장점도 많아서
     토큰인증의 가장 기본인 JWT에 대해 이해해야지 이후에 서드파티(?)를 이용한 로그인, OAuth 같은 인증방법들도 적용가능.


2. JWT 구조
   : 아래의 구조는 .으로 구분된다.
   - Header : 토큰의 타입(ex JWT), 적용된 알고리즘에 대한 정보.
   - Payload : 사용자와 토큰에 대한 속성 정보 (ex 로그인한 사용자의 이름, 토큰만료시간 등)
               Payload는 JWT 토큰만 가지고 있으면 누구나 디코딩해서 정보를 열어볼 수 있다는 특징이있다.
               따라서 비밀번호같은 민감정보는 포함하고 있으면 안된다.
   - Signature : 서명에 대한 부분.
                 토큰이 유효한지 위조된 것인지 확인하기 위해 사용된다.
                 서명을 하기위해 해당 비밀키를 필요로하게 된다.


< 토큰생성 >
1. 비밀키 생성
   - 토큰 생성시 HS512알고리즘 사용을 위해 -> 512비트(64바이트 이상)의 시크릿키 사용.
   - 평문을 사용하기보다는 base64로 인코딩한 값을 사용.
   - 터미널에서 생성가능.
     : 평문키 파일을 생성해 base64로 인코딩한 새파일 생성
        C:\workspace\Dividend\src\main\resources\token>certutil -encode jwt_secret_key.txt jwt_secret_key_encoding.b64
        입력 길이 = 46
        출력 길이 = 122
        CertUtil: -encode 명령이 성공적으로 완료되었습니다.
   - 도움받은 블로그 : https://interconnection.tistory.com/120

2. application.yml에 설정 추가
   - jwt:
        secret: '생성한 비밀키 등록'

3. TokenProvider.java





=============================== << 암호화 알고리즘 >> ===============================
평문 : 암호화 전 해독가능한 상태
암호문 : 암호화된 형태의 메시지
암호화(encryption) : 평문 -> 암호문
복호화(decryption) : 암호문 -> 평문
대칭키 : 동일키를 이용한 암,복호화시 대칭키를 사용한다고 한다.
비대칭키 : 메시지를 암,복호화하는 키가 다르면 비대칭키를 쓰는 알고리즘을 사용한 것이다.





